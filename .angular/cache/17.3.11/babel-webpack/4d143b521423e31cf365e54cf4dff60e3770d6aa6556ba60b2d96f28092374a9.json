{"ast":null,"code":"import _asyncToGenerator from \"/Users/maxime/Desktop/paris-boat-club-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { catchError } from 'rxjs/operators';\nimport { retry } from 'rxjs/operators';\nimport { HttpHeaders } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@ionic/angular\";\nexport let RedditService = /*#__PURE__*/(() => {\n  class RedditService {\n    constructor(http, alertController, toastCtrl) {\n      this.http = http;\n      this.alertController = alertController;\n      this.toastCtrl = toastCtrl;\n      this.URLbase = \"https://api.parisboatclub.blog/api/\";\n      this.URLImage = \"https://api.parisboatclub.blog/images/\";\n      this.language = \"EN\";\n      this.httpOptions = {\n        headers: new HttpHeaders({\n          'Content-Type': 'application/json'\n          // 'Access-Control-Allow-Headers': 'Origin, Content-Type, X-XSRF-TOKEN',\n          // 'Access-Control-Allow-Origin': 'http://localhost:8080'\n        })\n      };\n    }\n    ngOnInit() {}\n    login(data) {\n      return this.http.post(this.URLbase + 'login', data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    register(data) {\n      return this.http.post(this.URLbase + 'register', data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    forgetpassword(data) {\n      return this.http.post(this.URLbase + 'forgotpassword', data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    adduser(data) {\n      return this.http.post(this.URLbase + 'adduser', data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    postByid(table, id) {\n      return this.http.get(this.URLbase + table + '/' + id, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    addPost(table, data) {\n      return this.http.post(this.URLbase + table, data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    update(table, id, data) {\n      return this.http.put(this.URLbase + table + '/' + id, data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    updateinvoice(table, id, data) {\n      return this.http.post(this.URLbase + table + '/' + id, data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    delete(table, id) {\n      return this.http.delete(this.URLbase + table + '/' + id, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    sendByid(table, id) {\n      return this.http.post(this.URLbase + table + '/' + id, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    getDataBypage(page, table, per_page, order_id, order_by, category, status, filter) {\n      return this.http.get(this.URLbase + table + '?page=' + page + '&per_page=' + per_page + '&order_id=' + order_id + '&order_by=' + order_by + '&category=' + category + '&status=' + status + '&filter=' + filter).pipe(retry(2), catchError(this.handleError));\n    }\n    getDataBypageCalendar(page, table, per_page, startdate, enddate, priority, filter) {\n      return this.http.get(this.URLbase + table + '?page=' + page + '&size=' + per_page + '&startDate=' + startdate + '&endDate=' + enddate + '&active=' + priority + '&filter=' + filter).pipe(retry(2), catchError(this.handleError));\n    }\n    getDataAll(table) {\n      return this.http.get(this.URLbase + table).pipe(retry(2), catchError(this.handleError));\n    }\n    getByid(table, id) {\n      return this.http.get(this.URLbase + table + '/' + id, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    updateByid(table, data) {\n      return this.http.post(this.URLbase + table, data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    uploadImage(table, data) {\n      return this.http.post(this.URLbase + table, data, this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    uploadFormData(formData) {\n      return this.http.post('https://api.alpes-solutech.fr/api/upload', formData);\n    }\n    getGeocode(text) {\n      return this.http.get(\"https://api.geoapify.com/v1/geocode/search?text=\" + text + \"&apiKey=636cdf779a8c4b778f2cc84de97ced34\", this.httpOptions).pipe(retry(2), catchError(this.handleError));\n    }\n    getMessagesBythread(thread) {\n      return this.http.get(this.URLbase + 'public_chatgpt/' + thread).pipe(retry(2), catchError(this.handleError));\n    }\n    getUrlBase() {\n      return this.URLbase;\n    }\n    getUrlImage() {\n      return this.URLImage;\n    }\n    ///////////LOG \n    /** Log a HeroService message with the MessageService */\n    log(message) {\n      console.log(message);\n    }\n    // Handle API errors\n    handleError(error) {\n      return _asyncToGenerator(function* () {\n        console.log(error);\n        // alert(error.error[0].message);\n        if (error.error instanceof ErrorEvent) {\n          // A client-side or network error occurred. Handle it accordingly.\n          console.error('An error occurred:', error.message);\n        } else {\n          // The backend returned an unsuccessful response code.\n          // The response body may contain clues as to what went wrong,\n          console.error(`Backend returned code ${error.status}, ` + `body was: ${error.error}`);\n        }\n        // return an observable with a user-facing error message\n        // return throwError(\n        //  'Something bad happened; please try again later.');\n      })();\n    }\n    static #_ = this.ɵfac = function RedditService_Factory(t) {\n      return new (t || RedditService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.AlertController), i0.ɵɵinject(i2.ToastController));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: RedditService,\n      factory: RedditService.ɵfac\n    });\n  }\n  return RedditService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}